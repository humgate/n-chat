## Резюме
Репозиторий содержит выполнение курсового проекта "Сетевой чат" по курсу "Многопоточное и функциональное 
программирование".
## Постановка задачи
Требования к заданию изложены [здесь](https://github.com/netology-code/jd-homeworks/blob/master/diploma/networkchat.md "Постановка задачи")
## Описание архитектуры решения
Согласно [требованиям](https://github.com/netology-code/jd-homeworks/blob/master/diploma/networkchat.md "Постановка задачи")
решение состоит из двух приложений: сервера и клиента.
### Клиентское приложение
Клиентское приложение реализовано в виде двух потоков (Thread): Основного и Читающего. 
Основной поток выполняет следующие задачи:
1. Зачитывает настройки приложения из файла настроек.
2. Инициализирует приложение: Создает (если его еще нет) фолдер для записи лог файла клиента, хранящего сообщения чата.
3. Выполняет подключение к серверу в соответствии с параметрами, зачитанными из файла настроек.
4. Обеспечивает ввод пользователя из консоли

Читающий поток выполняет следующие задачи:
1. Слушает сервер, на предмет появления сообщений от сервера. 
2. При получении сообщений от сервера сохраняет их в файл серверного лога, а так же выводит их в консоль клиентского
приложения.

Задачи ввода сообщений пользователем и вывода сообщений присланных сервером разнесены по двум потокам (Thread) для
обеспечения асинхронности этих двух операций. 
### Серверное приложение
Серверное приложение реализовано в виде четырех потоков:
1. <strong>Основной поток сервера. (Класс Server)</strong>. Обеспечивает запуск сервера, зачитывание параметров из
файла настроек, запуск остальных потоков сервера и взаимодействие с пользователем через консоль (
слушанье в консоли команды пользователя "Stop").
2. <strong>Поток-регистратор новых пользователей чата. (Класс ClientHandler)</strong>. Выполняет подключение 
клиентов к чату. Обеспечивает нужные операции по работе с подключившимися клиентами. Содержит актуализируемый 
список клиентов в формате `Имя клиента`,`Канал клиента`. Регистрирует подключившегося клиента в списке 
клиентских каналов для прослушивания сообщений от них. Данную функцию можно принципиально реализовать с помощью 
селектора, так как же как реализован поток-слушатель (описан далее). Однако, я решил вынести функцию регистрации 
новых клиентов в чате в отдельный поток, который работает в блокирующем режиме. В настоящем чате по-хорошему
должна быть аутентификация пользователей с помощью ведения их учетных записей. Плюс к тому в настоящем чате,
наверняка потребуются какие-то функции авторизации и различные уровни доступа к разным функциям чата. Соответственно,
хоть в данном решении не реализовано функционала ведения учетных записей, аутентификации и авторизации, 
- архитектурно, мне видится, более правильным вынести этот модуль "авторизации" в отдельный поток от основного
потока-слушателя клиентов. Такое решение позволяет удобнее реализовать специфические функции авторизации клиентов
прежде чем их пустить в чат.  Так же, такое решение, позволяет более правильно реализовать логику противодействия
DDoS, нежели чем решение, когда все операции выполняются в одном потоке в селекторе. Плюс к тому, отделение логики
аутентификации от логики прослушивания-обработки сообщений от уже аутентифицированных клиентов, позволяет проще 
технически написать каждый из этих отдельных потоков. 
3. <strong>Поток-слушатель списка подключенных клиентских каналов. (Класс MessageBroker)</strong>. Прослушивает 
список зарегистрированных ("аутентифицированных") клиентских онлайн каналов на предмет появления сообщений от клиентов.
При получении сообщения от клиента сохраняет его в серверный лог файл и выполняет бродкаст рассылку сообщения 
от клиента всем онлайн клиентам. Технически слушатель реализован с применением селектора (Selector) из библиотеки 
java.nio. Технология селектора хороша тем, что позволяет очень эффективно использовать потоки (Threads) для организации 
неблокирующего взаимодействия сервера с несколькими клиентами. Фактически на сервере при применении селектора 
запускается всего один поток для обслуживания всех клиентов. При этом код с применением селектора выглядит достаточно 
просто. Плюс к тому селектор, очень эффективно обнаруживает отключившихся и упавших клиентов. 
4. <strong>Поток-писатель сообщений в файл. (Класс Logger)</strong>. Строго говоря, в явном виде в коде нигде не
запускается отдельный поток для записи сообщений в файл. Просто используются неблокирующие операции записи в файл 
из java.nio, что на верхнем уровне удобно рассматривать как будто это делается в отдельном потоке


 


